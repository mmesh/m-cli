package pro

import (
	"context"

	"github.com/AlecAivazis/survey/v2"
	"mmesh.dev/m-api-go/grpc/resources/resource"
	"mmesh.dev/m-api-go/grpc/resources/services/platform/pro"
	"mmesh.dev/m-cli/pkg/client/account"
	"mmesh.dev/m-cli/pkg/grpc"
	"mmesh.dev/m-cli/pkg/input"
	"mmesh.dev/m-cli/pkg/status"
	"mmesh.dev/m-cli/pkg/vars"
)

func GetServiceContract(providerAccount bool) *pro.ServiceContract {
	serviceContracts := serviceContracts(providerAccount)

	serviceContractsOpts := make([]string, 0)

	for contractID, _ := range serviceContracts {
		serviceContractsOpts = append(serviceContractsOpts, contractID)
	}

	contractID := input.GetSelect("Service Contract:", "", serviceContractsOpts, survey.Required)

	vars.ContractID = contractID

	return serviceContracts[contractID]
}

func serviceContracts(providerAccount bool) map[string]*pro.ServiceContract {
	a := account.GetAccount()

	nxc, grpcConn := grpc.GetServicesAPIClient(true)
	defer grpcConn.Close()

	lr := &pro.ListServiceContractsRequest{
		Meta:      &resource.ListRequest{},
		AccountID: a.AccountID,
	}

	serviceContracts := make(map[string]*pro.ServiceContract)

	for {
		scl, err := nxc.ListServiceContracts(context.TODO(), lr)
		if err != nil {
			status.Error(err, "Unable to list service contracts")
		}

		for _, sc := range scl.ServiceContracts {
			if providerAccount {
				if sc.AccountID == sc.ProviderAccountID {
					serviceContracts[sc.ContractID] = sc
				}
			} else {
				if sc.AccountID == sc.CustomerAccountID {
					serviceContracts[sc.ContractID] = sc
				}
			}
		}

		if len(scl.Meta.NextPageToken) > 0 {
			lr.Meta.PageToken = scl.Meta.NextPageToken
		} else {
			break
		}
	}

	return serviceContracts
}
